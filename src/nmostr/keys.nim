## Secp256k1 key management - for nmostr.
# Copyright © 2023 Gruruya <gruruya.chi4c@slmails.com>
# SPDX-License-Identifier: AGPL-3.0-only
#
# This file incorporates work covered by the following copyright:
#   Copyright © 2019-2023 Status Research & Development GmbH
#   SPDX-License-Identifier: MIT

### Description
## Subset of libsecp256k1 wrapped, with some convenience, for use with Nostr.
##
## See also:
## * `hexobjs <hexobjs.html>`_
## * `status-im/nim-secp256k1 <https://github.com/status-im/nim-secp256k1>`_
## * `bitcoin-core/secp256k1 <https://github.com/bitcoin-core/secp256k1>`_

import ./hexobjs, pkg/secp256k1/abi, std/options
from   pkg/secp256k1 {.all.} import getContext, Rng
from   pkg/stew/arrayops import assign
from   std/sysrand import urandom

export Rng, hexobjs
{.push inline.}


### § Secret keys
## Secret keys are not used in messages, so they are implemented here and without a `hex` field.

type
  SecretKey* = object
    raw*: array[32, byte]

template bytes*(v: SecretKey): array[32, byte] =
  v.raw
template toBytes*(v: SecretKey): array[32, byte] =
  v.raw
template bytesLen*(T: typedesc[SecretKey]): Positive =
  T.raw.len

func toHex*(v: SecretKey): StackString[64] =
  toHex(v.raw)

func `$`*(v: SecretKey): string =
  $toHex(v)

func toString*(v: SecretKey): string =
  toString(toHex(v))

func fromBytes*(T: typedesc[SecretKey], data: openArray[byte]): SecretKey =
  SecretKey(raw: toArray(32, data))

func fromBytes*(T: typedesc[SecretKey], data: array[32, byte]): SecretKey =
  SecretKey(raw: data)

func fromHex*(T: typedesc[SecretKey], hex: auto): SecretKey =
  SecretKey(raw: array[32, byte].fromHex(hex))

{.pop inline.}
proc sysRng*(data: var openArray[byte]): bool =
  ## Fill `data` with random bytes generated by your operating system.
  try: assign(data, cast[seq[byte]](urandom(data.len)))
  except OSError: return false
  result = true
{.push inline.}

proc random*(T: type SecretKey, rng: Rng = sysRng): T =
  ## Generates new random private key
  ##
  ## This function may fail to generate a valid key if the RNG fails. In the
  ## current version, the random number generation will be called in a loop
  ## which may be vulnerable to timing attacks. Generate your keys elsewhere
  ## if this is a issue.
  var data{.noinit.}: array[32, byte]

  while rng(data):
    if secp256k1_ec_seckey_verify(secp256k1_context_no_precomp, addr data[0]) == 1:
      return T.fromBytes(data)

  raise newException(OSError, "cannot get random bytes for key")

func toPublicKey*(key: SecretKey): PublicKey =
  ## Calculate and return Secp256k1 public key from private key ``key``.
  var pubkey {.noinit.}: secp256k1_pubkey
  var ret =
    secp256k1_ec_pubkey_create(getContext(), addr pubkey, addr key.raw[0])
  assert ret == 1, "valid private keys should always have a corresponding pub"
  ret =
    secp256k1_xonly_pubkey_from_pubkey(secp256k1_context_no_precomp, cast[ptr secp256k1_xonly_pubkey](addr result), nil, addr pubkey)
  assert ret == 1, "valid pubkeys should always be convertable to x-only"
  populateHex(result)

when isMainModule:
  from std/sugar import dump
  let privateKey = SecretKey.random()
  let bytReflected = SecretKey.fromBytes(privateKey.toBytes)
  let hexReflected = SecretKey.fromHex(privateKey.toHex)
  doAssert bytReflected == SecretKey.fromBytes(privateKey.toBytes)
  doAssert hexReflected == bytReflected
  dump privateKey


### § Signing with keypairs
## Schnorr signatures using Secp256k1 keys.
## Keypair objects containing a private and public key.

func signSchnorr*(key: SecretKey, msg: openArray[byte], randbytes: Option[array[32, byte]]): SchnorrSig =
  ## Sign message `msg` using private key `key` with the Schnorr signature algorithm and return signature object.
  ## `randbytes` should be an array of 32 freshly generated random bytes.
  let aux_rand32 = if randbytes.isSome: addr randbytes.unsafeGet[0] else: nil
  let extraparams = secp256k1_schnorrsig_extraparams(magic: SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC, noncefp: nil, ndata: aux_rand32)
  var kp {.noinit.}: secp256k1_keypair
  let res = secp256k1_keypair_create(
    getContext(), addr kp, addr key.raw[0])
  assert res == 1, "cannot create keypair, key invalid?"

  var data {.noinit.}: array[64, byte]
  let res2 = secp256k1_schnorrsig_sign_custom(getContext(), addr data[0], addr msg[0], csize_t msg.len, addr kp, unsafeAddr extraparams)
  assert res2 == 1, "cannot create signature, key invalid?"
  SchnorrSig.fromBytes(data)

proc signSchnorr*(key: SecretKey, msg: openArray[byte], rng: Rng = sysRng): SchnorrSig =
  ## Sign message `msg` using private key `key` with the Schnorr signature algorithm and return signature object.
  ## Uses ``rng`` to generate 32-bytes of random data for signature generation.
  var data: array[32, byte]
  if likely rng(data):
    signSchnorr(key, msg, some data)
  else:
    raise newException(OSError, "cannot get random bytes for signature")

func verify*(sig: SchnorrSig, msg: openArray[byte], pubkey: PublicKey): bool =
  secp256k1_schnorrsig_verify(
    getContext(), addr sig.raw[0], addr msg[0], csize_t msg.len, cast[ptr secp256k1_xonly_pubkey](addr pubkey)) == 1

type
  Keypair* = object
    ## Representation of private/public keypair.
    seckey*: SecretKey
    pubkey*: PublicKey

func init*(T: typedesc[Keypair]; seckey: SecretKey): Keypair =
  Keypair(seckey: seckey, pubkey: seckey.toPublicKey)

proc init*(T: typedesc[Keypair]; rng: Rng = sysRng): Keypair =
  Keypair.init(random(SecretKey, rng))

template toKeypair*(seckey: SecretKey): Keypair =
  init(Keypair, seckey)

converter toSecretKey*(kp: Keypair): lent SecretKey =
  kp.seckey

when isMainModule:
  let kp = Keypair.init()
  var msg = "Hello, world!"
  let sig = signSchnorr(kp, msg.toOpenArrayByte(0, msg.high))
  dump kp
  dump sig
