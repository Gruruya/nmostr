# nmostr --- Nim library for working with the Nostr protocol.
# Copyright Â© 2023 Gruruya <gruruya.chi4c@slmails.com>
#
# This file is part of nmostr.
#
# nmostr is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# nmostr is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with nmostr.  If not, see <http://www.gnu.org/licenses/>.

## Private/public key creation and management

# Types from `secp256k1` without {.requiresInit.} so that they can be null without using `stew/results`

import pkg/secp256k1, pkg/secp256k1/abi
from   pkg/stew/byteutils import toHex, fromHex
from   pkg/stew/arrayops import assign
from   std/sysrand import urandom
from   std/strutils import repeat
import std/importutils; privateAccess(SkXOnlyPublicKey); privateAccess(SkSchnorrSignature)
import pkg/jsony
export secp256k1 except fromRaw, fromHex

{.push raises: [], inline.}

type
  SecretKey* = SkSecretKey

  PublicKey* = object
    ## Representation of public key that only reveals the x-coordinate.
    ## Modified from `secp256k1` to not have `{.requiresInit.}`
    data*: secp256k1_xonly_pubkey
    hex*: string = repeat('0', 64)

  SchnorrSignature* = object
    ## Representation of a Schnorr signature.
    ## Modified from `secp256k1` to not have `{.requiresInit.}`
    data*: array[SkRawSchnorrSignatureSize, byte]
    hex*: string = repeat('0', SkRawSchnorrSignatureSize * 2)

converter toPublicKey*(pubkey: SkXOnlyPublicKey): PublicKey = PublicKey(data: pubkey.data, hex: pubkey.toHex)
converter toSkXOnlyPublicKey*(pubkey: PublicKey): SkXOnlyPublicKey = SkXOnlyPublicKey(data: pubkey.data)
converter toSchnorrSignature*(sig: SkSchnorrSignature): SchnorrSignature = SchnorrSignature(data: sig.data, hex: sig.toHex)
converter toSkSchnorrSignature*(sig: SchnorrSignature): SkSchnorrSignature = SkSchnorrSignature(data: sig.data)

func toException[T](v: cstring): ref ValueError =
  (ref ValueError)(msg: v)

func fromRaw*(T: type PublicKey, data: openArray[byte]): T {.raises: [ValueError].} =
  ## Additionally accepts 33 byte compressed public keys, should upstream this
  if likely data.len == 32: SkXOnlyPublicKey.fromRaw(data).tryGet
  elif data.len == 33: SkXOnlyPublicKey.fromRaw(data[1..^1]).tryGet
  else: raise newException(ValueError, "secp: x-only public key must be 32 or 33 bytes")

func fromHex*(T: type PublicKey, data: string): T {.raises: [ValueError].} =
  T(data: SkXOnlyPublicKey.fromRaw(array[32, byte].fromHex(data)).tryValue.data, hex: data)

func fromRaw*(T: type SchnorrSignature, data: openArray[byte]): T {.raises: [ValueError].}=
  T.fromRaw(data).tryGet

func fromHex*(T: type SchnorrSignature, data: string): T {.raises: [ValueError].} =
  T(data: array[64, byte].fromHex(data), hex: data)

func fromRaw*(T: type SecretKey, data: openArray[byte]): T {.raises: [ValueError].} =
  secp256k1.fromRaw(T, data).tryGet

func fromHex*(T: type SecretKey, data: string): T {.raises: [ValueError].} =
  secp256k1.fromHex(T, data).tryGet

func toRaw*(pubkey: PublicKey): array[SkRawXOnlyPublicKeySize, byte] =
  ## Wrapper that checks if `pubkey` is uninitialized
  if pubkey == default(PublicKey): return
  secp256k1.toRaw(pubkey)

func toHex*(hash: PublicKey | SchnorrSignature): string =
  hash.hex

func verify*(sig: SchnorrSignature, msg: SkMessage, pubkey: PublicKey): bool =
  ## Wrapper that checks if `pubkey` is uninitialized
  if pubkey == default(typeof pubkey): false
  else: secp256k1.verify(sig, msg, pubkey)

func verify*(sig: SchnorrSignature, msg: openArray[byte], pubkey: PublicKey): bool =
  ## Wrapper that checks if `pubkey` is uninitialized
  if pubkey == default(typeof pubkey): false
  else: secp256k1.verify(sig, msg, pubkey)

func `$`*(v: PublicKey | SchnorrSignature): string =
  toHex(v)

{.pop.}
{.push raises: [].}

# Keypairs
type Keypair* = object
  ## Representation of private/public key pair.
  seckey*: SecretKey
  pubkey*: PublicKey

converter toKeypair*(keypair: SkKeyPair): Keypair {.inline.} =
  Keypair(seckey: keypair.seckey, pubkey: keypair.pubkey.toXOnly)

converter toKeypair*(seckey: SecretKey): Keypair {.inline.} =
  Keypair(seckey: seckey, pubkey: seckey.toPublicKey.toXOnly)

proc sysRng*(data: var openArray[byte]): bool =
  ## Fill `data` with random bytes generated by the operating system.
  try: assign(data, cast[seq[byte]](urandom(data.len)))
  except OSError: return false
  result = true

proc newKeypair*(rng: Rng = sysRng): Keypair {.raises: [OSError].} =
  let secretKey = SkKeyPair.random(rng)
  if likely secretKey.isOk: toKeypair secretKey.unsafeGet
  else: raise newException(OSError, $secretKey.error()) # Assumes OSError

# JSON interop
func parseHook*(s: string, i: var int, v: var PublicKey) {.inline, raises: [JsonError, ValueError].} =
  ## Parse `id` as a hexadecimal encoding (of a sha256 hash).
  var j: string
  parseHook(s, i, j)
  # WARNING: Replaces invalid with nulled pubkey
  v = try: PublicKey.fromHex(j) except: default(typeof v)

func parseHook*(s: string, i: var int, v: var SchnorrSignature) {.inline, raises: [JsonError, ValueError].} =
  ## Parse `id` as a hexadecimal encoding (of a sha256 hash).
  var j: string
  parseHook(s, i, j)
  # WARNING: Replaces invalid with nulled signature
  v = try: SchnorrSignature.fromHex(j) except: default(typeof v)

func dumpHook*(s: var string, v: PublicKey | SchnorrSignature) {.inline.} =
  ## Serialize `pubkey` and `sig` into hexadecimal.
  dumpHook(s, v.toHex)
